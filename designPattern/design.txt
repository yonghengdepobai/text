

高阶函数
    是指至少满足下列条件之一的函数
    函数可以作为参数被传递
        1。回调函数
    函数可以作为返回值输出
AOP(面向切面编程)的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括日志统计、安全控制、
异常处理等。把这些功能抽离出来之后，再通过’动态织入‘的方式掺入业务逻辑模块中。这样做的好处是可以保持业务逻辑模块的纯净和
高内聚性，其次是可以很方便地复用日志统计等功能模块
通常在js中实现AOP，都是指把一个函数’动态织入‘到另一个函数中，


设计原则
单一原则（SRP）
就一个类(通常也包括对象和函数)而言，应仅有一个起它变化的原因。如果一个对象承担了多项职责，就意味着这个对象将变得巨大，
引起他变化的原因可能会有多个。面向对象设计鼓励将行为分布到细粒度的对象之中，如果一个对象承担的职责过多，等于把这些职责耦合到
了一起，这种耦合会导导致脆弱和低内聚的设计

策略模式指的是定义一系列的算法，把它们一个个封装起。将不变的部分和变化的部分分隔开是每个设计模式的主题
策略模式的目的就是将算法的使用与算法算法的实现分离开来
一个基于策略模式的程序至少由两部分组成。第一部分是一组策略，策略封装了具体的算法，并负责具体的计算过程。
第二部分是环境类context,context接受客户的请求，随后把请求委托给一个策略类。要做到这一点，说明context要维持对某个策略对引用


代理模式是为一个对象提供一个代用品或点位，以便控制对它的访问
代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身对象来控制对这个对象的访问，
客户实际访问的是替身对象。替身对象对请求做出一些处理之后，再把请求转交给本体对象
代理分为保护代理和虚拟代理
保护代理：比如代理B可以帮助A过滤掉一些请求 用于控制不同权限的对象目标的访问
虚拟代理：例如一些请求代价很大，又不知道对方什么时候能接收 可以让代理B来操作 把开销很大的对象，延迟到真正需要它的时候去创建
代理接口和本体接口的一致性
代理接口请求的过程对于用户来说是透明的，用户并不清楚代理和本体的区别
1.用户可以放心地请求代理，他只关心是否能得到想要的结果
2.在任何能使用本体的地方都可以使用代理

迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对像的内部表示。
迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即使不关心对象的内部构造，也可以顺序访问其中的每个元素

迭代器模式无非就是循环访问聚合对象中的各个元素

分为内部迭代和外部迭代
内部迭代
    内部迭代器在调用的时候非常方便，外界不关心迭代器内部的实现，跟迭代器的交互也仅仅是一次初始调用，但这也是
    内部迭代的缺点
外部迭代
    外部迭代器必须显式地请求下一个元素，增加了一些调用的复杂度，但相对也增强了迭代器的灵活性，我们可以手工控制迭代的过程或者
    顺序



发布订阅模式
    又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改时，所有依赖于它的对象都将得到通知
    一、可以广泛应用于异步编程
    二、可以取代对象之间的硬编码的通知机制

命令模式
    是最简单和优雅的模式之一，命令模式中的命令（command）指的是一个执行某些特定事情的指令
    最常见的应用场景是：有时候需要向某些对象发送请求，但是并不知道请求的接收是谁，也不知道被请求的操作是什么。些是
    希望用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系
    命令模式的由来，其实是回调（callback）函数的一个面向对象的替代品
    命令模式的作用不仅是封装运算块，而且可以很方便的地给命令对象增加撤消操作
    命令队列
        把请求封装成命令对象，对象的生命周期几乎是永久的，除非主动去回收它。也就是说命令对象的生命周期跟初始请求发生的时间
        无关，command对象的execute方法可以在程序运行的任何时该执行
    宏命令
        宏命令是一组命令的集合，通过执行宏命令的方式，可以执行一批命令。

组合模式
    将对象组合成树形结构，以表示“部分-整体”的层次结构。除了用来表示树形结构之外，组合模式的另一个好处就是通过对象
    提供了一种遍历树形结构的方案，通过调用组合对象的execute方法，程序会递归调用组合对象下面叶对象的execute方法

    的多态性表现，使得用户对单个对象和组合对象的使用具有一致性
    利用对象多态性统一对待组合对象和单个对象。利用对象的多态性表现，可以使客户端忽略组合对象和单个对象的不同。
    在组合模式中，客户将统一地使用组合结构中的所有对象，而不需要关心它究竟是组合对象还是单个对象

    组合模式不是父子关系    组合模式是一种HAS-A(聚合)的关系，而不是IS-A。组合对象包含一组叶对象，但Leaf并不是
    Composite的子类。组合对象把请求委托给它所包含的所有叶对象，它们能够合作的关键是拥有相同的接口
    对叶对象操作的一致性
    双向映射关系
    用职责链模式提高组合模式性能

    表示对象的部分-整体层次结构。组合模式可以方便地构造一棵树来表示对象的部分-整体结构。特别是我们在开发期间不确定这棵树到
    底存在多少层次的时候。在树的构造最终完成之后，只需要通过请求树的最顶层对象，便能对整棵树做统一操作。在组合模合模式中增加
    删除树的节点非常方便，并且符合开放-封闭原则

    客户希望统一对待树中的所有对象，组合模式使客户可以忽略组合对象和叶对象的区别，客户在面对这棵树的时候，不用关心当前正在处理
    的对象是组合对象还是叶对象

模板方法模式
    模板方法模式是一种只需要使用继承就可以实现的非常简单的模式
    模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。通常在抽象父类中封装了子类的算法框架，
    包括实现一些公共方法以及封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写
    父类的方法。

    抽象类
        模板方法严依赖抽象类的设计
    抽象类的作用
        抽象类不能被实例化
        抽象类和类口一样用于向上转型，除此也可以表示一种契约
        主要作用就是为它的子类定义这些公共接口。
    模板方法常被架构师用来搭建项目的框架

    构建一个UI组件
        1初始化一个div容器；
        2通过ajax请求拉取相应的数据；
        3把数据渲染到div容器里面，完成组件的构造
        4通知用户组件渲染完毕
    钩子方法（hook)，放置钩子是隔离变化的一种常见手段。我们在父类中容易变化的地方放置一个钩子，钩子可以有一个默认的实现
    究竟要不要钩子，这由子类自行决定。钩子方法的返回结果决定了模板方法后面部分的执行步骤，也就是程序接下来的走向

    好莱坞原则
        好莱坞无疑是演员的天堂，但好莱坞也有很多找不到工作的新人演员，许多新人演员在好莱
        坞把简历递给演艺公司之后就只有回家等待电话。有时候该演员等得不耐烦了，给演艺公司打电
        话询问情况，演艺公司往往这样回答：“不要来找我，我会给你打电话。”
    
    在这一原则指导下，我们允许底层组件将自已挂钩到高层组件中，而高层组件会决定什么时候、以何种方式去使用这些底层组件，
    高层组件对待底层组件的方式，跟演艺公司对待新人演员一样，都是 ”别调用我们，我们会调用你“

    当我们用模板方法模编写一个程序时，就间味着子类放弃了对自已的控制权，而改为父类通知子类，哪些方法应该在什么时候被调用
    作为子类，只负责提供一些设计上的细节

    模板方法模式是一种典型的通过封装变化提高系统扩展性的设计模式


享元模式
    享元（flyweight）模式是一种用于性能优化的模式，‘fly’在这里是苍蝇的意思，意为蝇量级。
    享元模式的核心是运用共享技术来有效支持大量细粒度的对象

    如果系统中因为创建了大量类似的对象而导致内存占用量过高，享元模式就非常有用了。
    享元模式要求将对象的属性划分为内部状态与外部状态（状态在这里通常指属性）享元模式的目标是减少共享对象的数量。
        内部状态存储于对象内部
        内部状态可以被一些对象共享
        内部状态独立于具体的场景，通常不会改变
        外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享
    剥离了外部状态的对象成为共享对象，外部状态在必要时被传入共享对象来组装成一个完整的对象。虽然组装外部状态成为一个完整对象的
    过程需要花费一定的时间，但却可以大大减少系统中的对象数量，相比之下，这点时间或许微不足道，因此
    享元模式是一种时间控空间的优化模式
    对象池是另一种性能优化方案，它跟享元模式有一些相似之处，但没有分离内部状态和外部状态这个过程


职责链模式
    是：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之的耦合关系，将这些对象连成一条链，并沿着这条链传递
    该请求，直到有一个对象处理它为止
    职责链模式的名字非常形像，一系可能会处理请求的对象连接成一条链，请求在这些对象之间依次传递，直到遇到一个可以处理它的对象
    我们把这些对象称为链点


面象对象设计鼓励将行为分布到各个对象中，把对象划分为成更小的粒度，有助于增强对象的可得用性，但由于这些细粒度对象之间的联系
激增，又有可能会反过来降低它们的可用性
中介者模式的作用就是解除对象之间的紧耦合关系。增加一个新对象后，所有的相关对象都通过中介对象来通信，而不是互相引用，所以当
一个对象发生改变时，只需要通知中介者对象即可。
中介者使各个对象之间耦合松散，而且可以独立地改变它们之间的交互。
中介者使网关的多对多关系变成了相对简单的一对多关系


装饰者模式
    在程序开发中，许多时候并不希望某个类天生就非常庞大，一次性包含许多职责。那么我们就可以使用装饰器动态的给某个对象添加
    一些额外的职责，而不会影响从这个类派生的其他对象

    给对象动态的地增加职责的方式称为装饰者（decorator）模式。装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象
    动态的添加职责。

    从结构上看，装饰者模式将一个对象嵌入另一个对象之中，实际上相当于这个对象被另一对象包装起来，开有成一条包装链。
    请求随着这条链依次传递到所有的对象，每个对象都有处理这个豆请求的机会

    装饰者模式和代理模式的结构看起来非常的像，这两种模式都描述了怎样为对象提供一定程度上的间接引用，它们的实现部分都保留了
    对另一个对象的引用，并且向那个对象发送请求。
    它们的主要区在于它们的意图和设计目的。代理模式的目的是，当直接访问本体不方便或者不符合需要时，为这个本体提供一个替代者。
    本体定义了关键功能，而代理提供或拒绝对它的访问，或者在访问本体之前做一些额外的事件。
    装饰者模式的作用就是为对象动态加入行为。换句话说，代理模式强调一种关系（Proxy与它的实体之间的关系），这种关系可以静态
    的表达，也就是说这种关系在一开始就可以被确定。而装饰者模式用于一个始不能确定对象的全部功能。
    代理模式通常只有一层代理——本体的引用，而装饰者模式经常会形成一条长长的装饰器链。



状态模式
    状态模式是一种非同寻常的优秀模式，它也许是解决某些需求场景的最好方法。
    状态模式的关键是区分事物内部的状态，事物内部状态的改变往往会带来事物行为的改变

    谈到封装，一般都会优先封装对象的行为，而不是对象的状态。但在状态模式中刚好相反，状态模式的关键是把事物是把每种状态都
    封装成单独的类，跟此种状态有关的行为都被封装到这个类的内部，所有button被按下的时候，只需要在上下文中，把这个请求委托
    给当前的状态对象即可，该状态对象会负责渲染它自身的行为
    同时我们还可以把状态的切换规则事先分布在状态类中，这样就有效地消除了原本存在的大量条件分支语句

    优点：状态模式定义了状态与行为之间的关系，并将他们封装到一个类里。通过增加新的状态类，很容易增加新的状态和转换
    避免Context无限膨胀，状态切换的逻辑被分布状态中，也去掉了Context中原本过多的条件分支
    用对象代替字符串来记录当前状态，使得状态的切换更加一目了然
    Context中的请求动作和状态类中封装的行为可以非常容易地独立变化而互不影响

    缺点：状态模式的缺点是会在系统中定义许多状态类，编写 20 个状态类是一项枯燥乏味的工作，
    而且系统中会因此而增加不少对象。另外，由于逻辑分散在状态类中，虽然避开了不受欢迎的条
    件分支语句，但也造成了逻辑分散的问题，我们无法在一个地方就看出整个状态机的逻辑。

    状态模式和策略模式像一对又胞胎，它们都封装了一系列的算法或行为，它们的类图看起几乎一模一样，但在意图上有很大不同
    相同点：它们都有一个上下文、一些策略或者状态类，上下文把请求委托给这些类业执行
    区别：策略模式中的各个策略之间是平等又平行的，它们之间没有任何联系，所以客户必须熟知这些策略的作用，以便客户可以随时主动
    切换算法；而在状态模式中，状态和状态对应的行为是早已被封装好了的，状态之间的切换也早被规定完成，’改变行为’这件事情发生在
    状态模式内部。以客户来说并不需要了解些细节。这正是状态模式的作用所在。


适配器模式
    适配器模式的作用是解决两个软件实体间的接口不兼容问题。使用适配器模式之后，原本由于接口不兼容而不能工作的两软件实体可以
    一起工作

    如果现有的接口已经能够正常工作，那我们永远不会用上适配器模式。适配器模式是一种‘亡羊补牢’的模式，没有人在程序设计之初就
    使用它。



    

