/**
 图形系统和模型

    1.输入设置
    2.中央处理单元（CPU）
    3.图形处理单元（GPU）
    4.存储器
    5.帧缓存
    6.输出设置

    所有的现代图形系统都是基于光栅的。在这样的图形系统中，在输出设备上看到的图像是一个由图形系统产生的图形元素组成的阵列
    图形元素也叫像素（pixel）,像素阵列也称为光栅（raster）

    每一个像素对应图像中的一个位置或者一块小的区域。这些像素都保存在一个称为帧缓存（framebuffer）的储存区域中
    帧缓存可以看成是图形系统的核心元素。帧缓存中像素的数目叫做分辩率（resolution）,它决定了图像中可以分辩出多少细节
    帧缓存的深度（depth）或者精度（precision）是表示每个像素所用的比特数，决定可以表示多少种颜色之类的性质
    在全彩色（full-color）系统中，每个像素有24个比特（或者更多）它们也被称为真彩色（true-color）系统，
    或者RGB颜色（RGB-color）系统

    处理器要完成的图形处理功能主要是获取由应用程序生成的图元（比如线条、圆、多边形）的属性，并为帧缓存中的像素赋值
    以最佳地表示这些图元

    从几何实何到帧缓存中像素的颜色和位置的转换称为光栅化（rasterization）或者扫描转换（scanconversion）


   属性
      把用来描述对象如何被绘制的方式称为属性（attribute）

   投影
      正投影

   线性空间（向量空间）[linear space(vector space)] 向量空量中包含两种不同的实体：向量和标量
   除此之外向量空间还定义了标量-向量乘法（scalar-vector multiplication）和向量-向量加法（vector-vector addition)
   向量空量中不一定要有度量。Euclid空间（Euclidean space）是向量的空间的扩展，它增加了对大小或者距离的度量，可以定义线段的
   长度等概念.Euclid空间中线段的大小就是它的长度
   仿射空间（affine space）也是向量空间的扩展，除了标量和向量，它还包括另外一种对象：点。在仿射空间中对两个点及一个点和标量
   没有定义运算，但对一个向量和一个点定义了运算：向量-点加法，它的结果是一个点。也可以说有点-点减法运算，这种运算由两个点得到
   一个向量

   在这些抽象空间中，对象的定义不依赖于任何特定的表示，对象只是各种集合中的元素。向量空间的主要概念之一是通过一组基向量来表示
   向量。这种表示把抽象的对象和它们的实现关联在一起。在不同的表示之间可以进行转换，这就引出了几何变换

   计算机科学更愿意把标量、点和向量它们看成是抽象数据类型（Abstract Data Type, ADT）.ADT是在数据上定义一些运算，这些运
   算的定义不依赖于数据在计算机内部的表示方式和运算的具体实现。

   在计算机图形学中，标量是实数，在标量之间可以进行通常的加法和乘法；几何点是空间中的位置；向量是有向线段；
   这些对象遵循仿射空间的运算规则

   如果对于一个对象中的任意两个点，连接它们的线段上所有的点仍然位于这个对象中，那么这个对象就是凸的（convex）

   点积和叉积
      与两个向量的方向关系有关的许多几何概念都是用这两个向量的点积（内积）（dot product 或 inner product）和
      叉积（外积）(cross product 或 outer product)来表述的。
      u和v的点积记为u·v。如果u·v=0，就说u和v是正交（是垂直这一直观这一直观概念的推广）的。在Euclid空间中，向量的长度是有定义的。
      一个向量的长度可由点积给出
      |u|^2 = u · u;
      两个向量夹角的余弦
      cosp = (u · v) / (|u| |v|);
      此外 |u|cosp = u · v / |v| 是u在v上的正交投影的长度

      在向量空间中，如果一组向量中的任何一个向量都不能由其他向量通过标量-向量乘法和向量-向量加法表示，则称
      这组向量是线性无关的（linearly independent）。向量的维数（dimension）是线性无关向量组中向量数目的最大值
      如果一个向量空间的维数维数是n，那么任何n个线性无关的向量都构成一个基（basis)
      在三维空间中，给定任何三个线性无关的向量，可以通过点积构造出三个互正交的向量。
      
      还可以同不平行的两个向量u和v求出第三个向量n, 使得n与u和v都正交。这个向量是通过叉积（cross product)得到的
      n = u x u;



 矩阵 秩
   假定
      q = Ap;
   想知道能否找到一个方阵B使得
      p = Bq;
   把其中的q替换掉得，得
      p = Bq = BAp = Ip = p;
   于是
      BA = I;
   如果存在这样一个矩阵B,则称它是A的逆（inverse）, 并称A是非奇异的（nonsingular）。我们把不可逆的矩阵称为是
   奇异的（singular）
   逆矩阵的一个基本结论为：一个方阵的逆存在，当且仅当它的行列式不等于零。A的行列式记为|A|.
   
   对一般的行维数和列维数不相等非奇异矩阵，秩的概念是重要的。可以把一个方阵看成是一个行矩阵，其中的每个元素是列矩阵，
   或者等价的反过来。 按照向量空间的概念，一个nxm矩阵的行是Euclid空间Rm中的元素，而它的列是Rn中的元素。可以确定一个矩阵
   有多少行（或者列）是性线无关的（linerly independent）。行（列）秩（ranK)是线性无关的最大行（列）数。
   一个nxn矩阵的行秩和列秩相等，并且方阵是非奇异的，当且仅当它的秩等于n。因此，一个矩阵是可逆的，当且仅当它的行（或列）
   是线性无关的

   原点和基向量决定一个标架（frame）
   这样在一个标架下，表示一个向量需要三个标量，而表示一个点需要三个标量和原点的位置
   使用标架，可以避免由于向量具有大小和方向但是没有固定位置所带来的困难。此外，能够借助矩阵来表示点和向量，
   并且点和向量这两种几何类型的矩阵表示是有区别的

   假定向量e1, e2, e3构成了一个基。任一向量v在这个基下的表示可由一个向量a的分量（a1, a2, a3）给出，其中
   a1, a2, a3满足
   v = a1v1 + a2v2 + a3v3;

   在WebGL中，为了方便于场景中各个模型的建模，使用一种对模型很自然的坐标或者标架来定义几何对象，这个架标称为
   对象标架（object frame）或者建模标架（model frame）。然后这些对象标架中的模型又被放到世界标架（world frame）中
   有时我们需要知道这些对象在照相机中看来是什么样子的，此时就要从世界标架变换到照相机标架（camera frame）或者
   眼标架（eye frame）。从对象标架到眼标架的转换是由模-视变换矩阵完成的

   齐次坐标（homogeneous coordinate）
      点和向量在三维坐标中会被搞混的问题
      齐次坐标可以克服这个问题，它对三维空间中点和向量的表示都是四维的。
      在由（v1, v2, v3, p0）确定的标架中，任一点p可以唯一地表示为：
         p = a1v1 + a2v2 + a3v3 + P0
      如果把点与标量0和1的‘乘法’定义为
         0.p = 0; 1.p = p;
      那么矩阵乘法把点P形式地表示为

                              [ v1
                                v2
         p = [a1 a1 a3 1]       v3
                                p0
                              ]
                              
   
      等式右边的四维行矩阵就是p在由v1, v2, v3, p0所确定的标架下的齐次坐标表示（homogeneous-coordinate representation）
   
   WebGL 中的标架
      WebGl 基绘制流水线模型，而且绘制流水线的第一步骤是对顶点进行一系列的操作，这些操作可以用一系标架变换来表征，这些标架变换
      要应用到由用户程序所定义的对象上
      6个标架在绘制流水线中通常按照下面的先后顺出现：
         1. 建模坐标系0（model frame）
            往往在建模坐标系下指定对象，因为在这个标架可以方便地描述对象的大小、方向和位置
            一个场景可能包含成百上千个独立的对象。应用程序通常对每一个对象实施一系列的变换，这些变换可以改变他们的大小、方向
            和位置，从而使它们处于一个适合于该特定应用程序的标架中
         2. 对象坐标系或世界坐标系
            应用程序使用标架称为对象标架，而在这个标架下的坐标就是对象坐标（object coordinate）或世界坐标（world
            coordinate） 如果没有利用预先定义好的对象来建模，并且也没有应用任何变换，那么模模坐标和对象坐标系是相同的。
         3.眼坐标系或者照相机坐标系
            生成图像依赖于照相机或者观察者所能看到的内容。几乎所有的图形系统都使用这样一个标架，该标架的原点位于照相机镜头
            的中心，并且坐标轴平行于照相机的侧面，这就是照相机标架（camera frame）
            每次标架变换都对应一个仿射变换，所以从建模坐标到世界坐标以及从世界坐标到眼坐标都可以用4x4矩阵来表示。这两个变换
            通常合并为一个模-视变换（model-view transformation）, 对应的矩阵是模-视变换矩阵
            通常，使用模-视变换矩阵而不是两个单独的变换矩阵不会给程序员带来任何不便
         4.裁减坐标系（clip coordnate）
            把对象变换到眼坐标系中以后，WebGL就要检查它们是否位于视见体内。如果一个对象位于视见体外，那么就在光栅化之前把
            它从场景里裁减掉。为了更有效地进行裁减，WebGL先执行投影变换，这个变换把所有可能是可见的对象变换到一个立方体中，
            该立方体的中心是裁减坐标系的原点
         5.规范化的设备坐标系
            在投影变换后，顶点的表示仍是齐次坐标。顶点的齐次坐标表示再经过透视除法（perspective division）,即用w分量去
            除其他的分量，就得到了在规范化的设备坐标系（normalized device coordinate）下的三维表示
         6.窗口坐标系或者屏幕坐标系
            根据视口提供的信息，把规范化的设备坐标系下的表示变换为窗口坐标系（window coordinate）下的三维表示。
            窗口坐标是用显示器上的像素来度量的，但仍然保留了深度信息。如果去掉深度坐标，就得到了二维的屏幕坐标（screen
             coordinate）
      应用程序员通常处理两个标架：建模标架和世界标架
         

 矩阵变换
   WebGL中并没有一个可以操作的相机对象。然而我们可以假设我们渲染在canvas上的场景就是我们相机捕获的

   齐次坐标系 它使得我们能够使用4x4矩阵来表达仿射变换（旋转、缩放、切变、平移）和投影变换。
   在齐次坐标系中，顶点拥有四个部分：x, y, z, w。前三个部分是顶点在欧几里得空间中的坐标。第四个部分是透视部分。所以
   四元组（x, y, z, w）将我们带到了一个新的空间：投影空间

   齐次坐标使得我们可以在一种特殊的方程中求出解，这个方程组中每一个方程都表示一个与系统中其他直线平行的直线。
   知道在欧几里得空间中，对这种方程组是无解的，因为他们没有交点。然而在投影空间中，这种方程有解，这些直线将会在无穷远处相交。
   这些实际上代表了他们的透视部分的值是0 关于这种观点的一个很好物理类比就是想象一下所有的平行铁路都会来视线的终点处相交

   从齐次到欧几的变换
   h(x, y, z, w) = v(x / w, y / w, z / w);
      v(x, y, z) = h(x, y, z, 1);

   齐次坐标中 顶点有一个 w=1 的齐次坐标，向量的齐次坐标 w = 0 所以在顶点着色器中，法线向量的处理如下：
   vNormal = vec3(u_NormalMatrix * vec4(a_Position, 0.0));
   顶点处理如下：
   vec4 vertex = u_MvMatirx * vec4(a_Position, 1.0)

   Model transform 模型变换
      使用模型矩阵来乘以我们对象中的顶点，我们将会获得新的顶点坐标。这些新的顶点坐标决定物体在我们3d世界中的位置

   在对象坐标系，每个物体都可以自由定义它的原点然后指定它的顶点相对于原点的位置；
   在世界坐标系中，原点被所有的物体所共享。世界坐标允许我们知道物体相对于其他物体的位置。通过模型变换我们可以决定对象在3d
   世界中的位置

   View transform 视图变换
      将坐标系的原点转换到视点。视点是我们的眼睛或者相机相对于世界原点的位置。
      视图变换是通过视点坐标来切换世界坐标的
      我们通过模型变换后的顶点坐标来乘以这个矩阵。这个操作的结果是得到原点的一堆顶点坐标。我们将在这个坐标系中来操作我们的相机
   
   Projection transform 投景变换
      这个操作决定了多大的视点空间将被渲染和它将如何被匹配到计算机屏幕上。这个区域被称为视锥体，它由六个平面来定义
      （近平面、远平面、上底面、下底面、左平、右平面）
      这六个平面被编码在透视矩阵中。任何坐落于视锥体之外的顶点在应用投影变换后将被裁剪，并在后续的处理中被抛弃
      经透影变换的空间成为裁切空间。（透视矩阵由视锥体产生，经过透视矩阵变换后的空间称为载切空间， 顶点的w坐标可能不在是1）
      视锥体的形状和范围决定了从3d视点空间到2d屏幕的投影类型。如果远平面和近平面拥有相同的维度，视锥体将产生一个正射投影。
      否则将产生透视投影

      齐次坐标中，裁切坐标有四个部分：x, y, z, w。裁剪是是通过比较x, y, z与齐次坐示w。如果其中任何一个大于+w或者小于-w
      那么这个顶点位于视锥体外并被抛弃。
   perspective division 透视除法
      一旦决定了多大的视域空间将被渲染，视锥体将被匹配到近平面来为了产生一张2d图片。近景面的内容是将被渲染到我们计算机屏幕的内
      容

      为保证所有情况下的健壮性，webgl提供了一个独立于任何硬件的中介坐标系统。这个空间被称为归一化设备坐标（NDC）

      归一化设备坐标通过将获得的裁剪坐标除以w分量获得。这也就是为什么这一步叫做透视除法。
      当你除以齐次坐标后，我们从投影空间转到了欧几里得空间，所以NDC坐标只有三个分量。在NDC坐标中，x,y 坐标代表了你的顶点
      在归一化2d屏幕上的位置，而z坐标编码了深度信息，即物体相对于近景面和远景面的位置
      这允许webgl后面基于物体到近景面的距离来决定如何显示物体的叠盖关系

      透视除法将视锥体变换到一个立方体中，原点在立方体中心，最小坐标（-1, -1, -1)最大坐标（1, 1, 1)而且z轴的方向是相反的

   viewport transform 视口变换
      最后NDC被匹配到视口坐标。这一步将这些坐标映射到屏幕上的可视区域。在webgl中，这个区域由html5的canvas提供
      视点变换不是由矩阵产生的。在这里我们使用webgl的viewport函数

   Normal transformations 法线变换
    法线由 原法线坐标乘模型矩阵的逆转置矩阵 得到新的法线坐标


    视点矩阵
      视点变换确定了场景中物体的视点wugl置和方向，它象是在场景中放置了一架照相机，让照相机对准要拍摄的物体
      此变换过程就是将世界空间（也即世界坐标系）中的一点转换到视点空间（也即视点坐标系）后的坐标

      在OpenGL中，以逆时针旋转物体就相当于以顺时针旋转相机。
      因此，我们必须把视点转换和模型转换结合在一起考虑，而对这两种转换单独进行考虑是毫无意义的。
   

 */